Объявление всех функций должно быть в файле tasks_rk2.h, а реализация - tasks_rk2.cpp
проверку задач написать в файле main.cpp, для каждой задачи создать свою функцию в файле main.cpp с названием task_N(void), где N - номер задачи, 
к примеру функция для задачи 1 будет выглядить следующим образом void task_1(void) {...}, для второй - void task_2(void) {...} и т.д., 
каждая функция будет соответствовать решённой задаче.
Название функций, их параметры менять нельзя
Публичные методы и свойства в классе изменять и/или добавлять новые -- нельзя!

1. Реализовать класс "Граф". 
	Функция создания Графа int Graph::buildTreeBFS(int countNodes); -- если последний номер билета чётный
	0 - имя узла вершины дерева 
	создаёт дерево с числом детей в вершине дерева countNodes, а каждый последующий слой "детей" будет иметь countNodes-1,
	далее countNodes-2 и т.д. имена детей инкрементируются на 1
	0{1,2,3},1{4,5},2{6,7},3{8,9},4{10},5{11},6{12},7{13},8{14},9{15} -- дерево при countNodes = 3
	(в фигурных скобках перечислены имена "детей" через запятую, вне фигурных скобках - родитель)
	
	Функция создания Графа int Graph::buildTreeDFS(int countNodes); -- если последний номер билета нечётный
	0 - имя узла вершины дерева 
	создаёт дерево с числом детей в вершине дерева countNodes, а каждый последующий слой "детей" будет иметь countNodes-1,
	далее countNodes-2 и т.д. имена детей инкрементируются на 1
	0{1{2{3},4{5}},6{7{8},9{10}},11{12{13},14{15}}} -- дерево при countNodes = 3
	(в фигурных скобках перечислены имена "детей" через запятую, вне фигурных скобках - родитель)
		
	void Graph::BFS();	 функция обхода дерева в ширину
		при обходе графа записать результат в файл с название bfs_res 
		Формат файла 0{1,2,3}\n 1{4,5}\n 2{6,7}\n 3{8,9}\n 4{10}\n 5{11}\n 6{12}\n 7{13}\n 8{14}\n 9{15}
		\n -- новая строка
		
	void Graph::DFS();
		при обходе графа записать результат в файл dfs_res
		Формат файла 0{1{2{3},4{5}},6{7{8},9{10}},11{12{13},14{15}}}
	
	struct Node {
		Node();
		Node(int nameNode);
		~Node();
		
		Node* parent;
		std::list<Node*> listChilds;
		int name;
		static int countNodes;
	};
	
	class Graph {
		private :
			Node* head;
			//здесь можно писать любые функции, которые могут понадобиться
		public :
			Graph();			
			Graph(int countNodes);
			~Grpah();
			/*
				output		:	-1 - если функция не реализована
							:	положительное число -- число узлов
				author		:
				date		:
			*/
			int buildTreeBFS(int countNodes);
			/*
				output		:	-1 - если функция не реализована
							:	положительное число -- число узлов
				author		:
				date		:
			*/			
			int buildTreeDFS(int countNodes);
			
			void BFS();
			void DFS();
			/*
				description	:	функция поиска узла по его имени
				input 		:	nameNode -- имя узла
				output		:	{bool -- узел найде, list<int> -- список имён узлов до необходимого}
				description	:	приставка DFS -- поиск в глубину, BSF -- поиск в ширину
				author		:
				date		:
			*/
			std::pair<bool, list<int>> searchDFS(int nameNode);	
			std::pair<bool, list<int>> searchBFS(int nameNode);
	};
